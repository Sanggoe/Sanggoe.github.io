## 02. CPU의 구조와 기능

<br/>

#### 프로그램 수행

 - 모든 명령어에 대해 공통적으로 수행

 (1) 명령어 인출 : 기억장치로부터 명령어를 cpu로 읽어온다.

 (2) 명령어 해독 : 수행할 동작을 결정하기 위해 명령어를 해독한다.

 - 명령에 따라 필요한 경우에만 수행

 (3) 데이터 인출 : 명령어 실행을 위해 데이터가 필요한 경우, 기억장치나 I/O 장치로부터 데이터를 읽어온다.

 (4) 데이터 처리 : 데이터에 대한 산술적, 논리적 연산을 수행한다.

 (5) 데이터 저장 : 수행한 결과를 저장한다.

<br/>

<br/>

###  2.1 CPU의 기본 구조

\* 산술 논리 연산 장치(Arithmetic and Logical Unit: ALU) : 산술 및 논리 연산들을 수행하는 회로들로 이루어진

   하드웨어 모듈. 물리적인 실제 효과를 발생시킨다. CPU가 수행 가능한 실제 명령들.

 레지스터(register) : CPU 내부에 포함된 기억장치로, 액세스 속도가 기억장치 중 가장 빠르다.

   대신 회로가 복잡해 용량을 많이 차지해서, 많은 수를 포함할 수 없다.

  ![그림입니다.  원본 그림의 이름: cpu_1.jpg  원본 그림의 크기: 가로 480pixel, 세로 408pixel](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\tmp14BA.jpg)   제어 유니트(control unit) : 명령어를 해석하고, 실행하기 위한 제어 신호들(control signals)을

   순차적으로 발생시키는 하드웨어 모듈이다.

<br/>

 \- RISC : 명령어를 줄여 간단한 것들로 조합해서, 메모리를 적게 만들자는 입장

 \- CISC : 명령어를 다 담아, 속도를 빠르게 하자는 입장

<br/>

\* CPU 내부 버스(CPU internal bus) : ALU와 레지스터들 사이에

   데이터 이동을 위한 선들과 주소선들, 제어 유니트로부터

   발생되는 제어 신호들을 전송하는 선들로 구성된다.

   내부 버스 선들은 외부 시스템 버스와는 직접 연결되지 않으며,

   반드시 버퍼 레지스터나 인터페이스 회로를 통해 접속된다.

<br/>

  ![그림입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\tmp14DA.jpg)   2.2  명령어 실행

\* 명령어 사이클 : CPU가 한 개의 명령어를 실행하는데 필요한 전체 과정.

   명령어 인출 단계와 명령어 실행 단계로 나뉜다. 명령어 사이클은 CPU가

   프로그램을 시작한 순간부터 전원을 끄거나 회복 불가능한 오류가 발생

   하여 중단될 때 까지 수행 된다. 단, 명령어의 내용이 메인메모리에 저장

   되어있다는 가정 하에 수행 되는 것이다.

<br/>

 CPU의 명령 실행

<br/>

 \- 명령어 인출 단계  /  인출 사이클

 \- 명령어 실행 단계  /  실행 사이클

<br/>

 명령어 실행을 위해 기본적으로 필요한 CPU 내부 레지스터

 \- 프로그램 카운터(Program Counter: PC) : 다음에 인출될 명령어 주소를 가지고 있는 레지스터. 인출 된 후,

?    명령어 길이에 해당하는 주소의 단위 수만큼 증가되며, 분기 명령어 실행 시, 그 목적지 주소로 갱신된다.

 \- 누산기(Accumulator: AC) : 데이터를 일시적으로 저장하는 범용 레지스터. CPU가 한 번에 연산 처리할 수

?    있는 데이터 비트 수, 즉 단어(word)의 길이와 크기가 같다.

 \- 명령어 레지스터(Instruction Register: IR) : 가장 최근에 인출된 명령어가 저장되는 레지스터.

 \- 기억장치 주소 레지스터(Memory Address Register: IR) : PC에 저장된 명령어 주소가 시스템 주소 버스로 출력

?    되기 전에 일시적으로 저장되는 주소 레지스터. 시스템 주소 버스에 직접 접속이 일어나는 곳이다.

 \- 기억장치 버퍼 레지스터(Memory Buffer Register: MBR) : 기억장치에 저장될 데이터나, 읽힌 데이터가 일시적으

?    로 저장되는 버퍼 레지스터. 시스템 데이터 버스와 직접 접속이 일어나는 곳이다.

<br/>

  ![그림입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\tmp14FB.jpg)  * 이동 경로 예

 PC -> MAR -> 기억장치 -> MBR -> AC 또는 IR

<br/>

<br/>

#### 2.2.1  인출 사이클

\* 인출 사이클 : 기억장치의 지정된 위치로부터 명령어를 읽어오는 과정

<br/>

 마이크로-연산(micro-operation)

  : CPU 클록의 각 주기 동안에 수행되는 기본적인 동작

  ![사각형입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\DRW0000684c3885.gif)  

?       t : CPU 클록의 각 주기

?       ex) 한 주기가 1ns이면

?           이 연산은 총 3ns.

<br/>

<br/>

#### 2.2.2  실행 사이클

\* 실행 사이클 : CPU가 인출된 명령어 코드를 해독하고, 결과에 따라 필요한 연산들을 수행하는 과정

 \- 데이터 이동 : CPU와 기억장치, I/O 장치간에 데이터를 이동한다.

 \- 데이터 처리 : 데이터에 대해 산술 혹은 논리연산을 수행한다.

 \- 데이터 저장 : 연산결과 데이터나 입력 장치에서 읽어 들인 데이터를 기억장치에 저장한다.

 \- 프로그램 제어 : 프로그램의 실행 순서를 결정한다.

<br/>

 마이크로-연산(micro-operation) : 실행 사이클에서는 명령어의 종류에 따라 달라진다.

 명령어 형식 : 수행할 연산을 지정할 연산코드 / 연산 수행에 필요한 오퍼랜드(addr)

  오퍼랜드는 명령어가 사용할 데이터가 저장된 기억장치의 주소를 가리킨다고 가정!

<br/>

  ![사각형입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\DRW0000684c3885.gif)   (1) 데이터 이동 : LOAD addr

?       t : CPU 클록의 각 주기

<br/>

 (2) 데이터 저장 : STOR addr

  ![사각형입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\DRW0000684c3885.gif)

?       t : CPU 클록의 각 주기

<br/>

 (3) 데이터 처리 : ADD addr

  ![사각형입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\DRW0000684c3885.gif)

?       t : CPU 클록의 각 주기

<br/>



 (4) 프로그램 제어 : JUMP addr

  ![사각형입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\DRW0000684c3885.gif)

?       t : CPU 클록의 각 주기

<br/>

#### 2.2.3 인터럽트 사이클

\* 인터럽트 : 프로그램 실행 중 CPU의 현재 처리순서를 중단시키고 다른 동작을 수행하도록 하는 시스템 동작.

?     (외부 입출력 장치가 CPU에게 문제점을 보내줌)

\* 인터럽트 서비스 루틴(Interrupt Service Routine: ISR) : 인터럽트 요구 처리를 위해 수행하는 프로그램 루틴.

 \- CPU가 프로그램을 순차적으로 수행하는 도중에 인터럽트 요구가 들어오게 되면, 원래 프로그램 수행을 중단하고

   요구된 인터럽트를 처리해주기 위한 프로그램 루틴을 먼저 수행한다. (컴퓨터 언어에서 함수 호출과 비슷함)

  ![그림입니다.  원본 그림의 이름: 7.PNG  원본 그림의 크기: 가로 383pixel, 세로 633pixel](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\tmp1569.jpg)  

\* 인터럽트가 들어왔을 때

 \- CPU는 어떤 장치가 인터럽트를 요구했는지 확인 후 해당 ISR을 호출

 \- 서비스 종료 후, 중단 되었던 기존의 프로그램 수행

\* CPU 인터럽트 처리 세부동작

 \- 현재 명령어 실행을 끝낸 즉시, 다음에 실행 할 주소(PC의 내용)를 스택(stack)에 저장

  => 인터럽트 처리 후 복귀할 주소를 저장해 두기 위한 절차.

 \- ISR 호출을 위해 그 루틴의 시작 주소를 PC에 적재

  => 이 때 주소는 인터럽트 요청 장치로부터 전송되거나 미리 정해진 값으로 결정.

<br/>

\* 인터럽트 사이클 : 인터럽트 요구 신호 검사, Stack ← PC, PC ← ISR의 시작주소를

   적재하는 과정. 인터럽트 가능 상태, 인터럽트 불가능 상태가 있다.

<br/>

 인터럽트 요구 시, 사이클 수행 동작 마이크로-연산

  ![사각형입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\DRW0000684c3885.gif)

?       t : CPU 클록의 각 주기

?       SP : 스택 포인터(stack pointer)로, 항상 최 상위 스택주소를 가리킨다.

?        (여섯 번째 레지스터)

<br/>

ex) 100번지의 명령어가 수행되는 도중에 인터럽트가 들어온 경우

 100  LOAD  250

 101  ADD   251  SP에는 999가 저장되어 있음

 102  STA    251 인터럽트 서비스 루틴의 시작주소는 650이라 가정

 103  JUMP  170

 \- 실행 사이클 후, 인터럽트 사이클에서 요구 신호 인식

 \- PC의 내용이 MBR을 통해 SP가 지정하는 최 상위 스택 999번지에 저장

 \- PC에 인터럽트 서비스 루틴의 시작 주소인 650을 저장

 \- SP의 내용은 1이 감소, 998이 됨

\* 명령어 실행 결과가 AC 레지스터에 적재되어 있는데, 인터럽트 서비스 루틴이 수행되는 동안 AC 내용이 바뀌면,

  나중에 원래 프로그램으로 돌아왔을 때 다음 명령어의 실행 결과가 틀리게 된다. 따라서 레지스터들의 내용을

  스택에 저장하였다가, 루틴의 마지막 단계에서 원래 프로그램으로 돌아가기 직전에 복원시켜주는 절차가 필요.

<br/>

   * 다중 인터럽트(multiple interrupt) : ISR 수행 도중 다른 외부장치에 의해 인터럽트 요구가 발생하는 경우.

![그림입니다.  원본 그림의 이름: 20160908134622511.png  원본 그림의 크기: 가로 513pixel, 세로 439pixel](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\tmp15A8.jpg)

 \- 처리하는 방법

 (1) CPU가 ISR수행 도중에는 새로운 인터럽트 요구가 들어와도 사이클을 수행하지 않는

   방법. 즉, 인터럽트 불가능 상태일 때는 CPU가 인터럽트 요구 신호를 검사하지 않도록

   한다. 그 동안 요구는 대기상태였다가, 인터럽트 가능 상태로 바뀐 후 인식된다.

 (2) 인터럽트 요구들 간 우선순위를 정하고, 더 높은 인터럽트 요구가 들어오면 기존에

   수행하던 인터럽트 서비스 루틴의 수행을 중단하고 새로운 인터럽트를 먼저 처리

   하도록 하는 방법. 이 경우, 단일 인터럽트와 같이 스택 메모리에 주소를 저장하는

   방식으로 동일하다. (돌아올 위치를 스택 메모리에 저장)

<br/>

#### 2.2.4 간접 사이클

\* 간접 사이클 : 실행 사이클에서 사용될 데이터의 실제 주소를 기억장치로부터 읽어오는 과정

\* 마이크로-연산

  ![사각형입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\DRW0000684c3885.gif)

?       t : CPU 클록의 각 주기

<br/>

<br/>

###  2.3 명령어 파이프라이닝

\* 명령어 파이프라이닝 : 처리 속도를 향상시키기 위해 명령을 단계별로 분할하여 성능을 높이는 기술

<br/>

####   2.3.1  2-단계 명령어 파이프라인

![그림입니다.  원본 그림의 이름: 1.PNG  원본 그림의 크기: 가로 531pixel, 세로 307pixel](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\tmp15C9.jpg)

 \* 인출 단계와 실행 단계라는 두 개의 파이프라인 단계들로 분리하여 구성.

   첫 번째 주기에서는 명령어를 인출한다. 두 번째 주기에서는 인출된 명령어를

   실행하고, 동시에 두 번째 명령어를 인출한다. 이런 방식으로 구성.

 이론적으로는 최대 두 배의 속도 향상을 얻지만, 실제로 각 명령어 단계의

   처리 속도가 동일하지 않기 때문에 그렇지는 못 함. 해결책으로는 파이프라인

   단계 수를 증가시켜 각 단계의 처리시간을 같게 해주는 방법이 있음.

<br/>

  ![그림입니다.  원본 그림의 이름: 2.PNG  원본 그림의 크기: 가로 648pixel, 세로 376pixel](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\tmp15E9.jpg)  

<br/>

#### 2.3.2  4-단계 명령어 파이프라인

 \* 처리 시간이 더 긴 파이프라인 단계를 여러 개로 분할하여

   단계들의 처리 시간이 거의 같아지도록 한다.

 \- 명령어 인출(IF) : 명령어를 기억장치로부터 인출

 \- 명령어 해독(ID) : 해독기를 이용해 명령어 해석

 \- 오퍼랜드 인출(OF) : 기억장치로부터 오퍼랜드를 인출

 \- 실행(EX) : 지정된 연산 수행, 결과를 저장

<br/>

 파이프라이닝을 이용해 얻을 수 있는 속도 향상의 관계식

  ![묶음 개체입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\DRW0000684c3893.gif)  

  k : 파이프라인의 단계 수

  N : 실행할 명령어들의 수

  T : 전체 명령어 실행 시간

  Sp : 속도 향상 (배)

<br/>

####  4-단계 파이프라인의 문제점.

 (1) 모든 명령어들이 네 개의 파이프라인 단계들을 모두 거치는 것은 아니다. 예를 들어 실행 단계에서 오퍼랜드

?    인출이 필요 없는 경우도 있기에 수행되지 않아도 될 OF명령을 수행하는데 필요 없이 시간이 소모된다.

 (2) 파이프라인 클록은 처리시간이 가장 오래 걸리는 단계를 기준으로 정해져야 한다. 따라서 이 역시 수행을

?    완료하고 다른 명령어들이 수행이 끝날 때 까지 기다리며 시간이 소모된다.

 (3) 기억장치 충돌이 일어날 수 있다. 명령어 인출(IF)과 오퍼랜드 인출(OF)단계는 모두 두 기억장치나 캐시를

?    액세스해야 하는데, 하나의 모듈에 두 단계가 동시에 액세스할 수 없기에 둘 중 하나는 반드시 지연된다.

  ![그림입니다.  원본 그림의 이름: 그림_2-10._조건_분기가_존재하는_경우의_시간_흐름도.jpg  원본 그림의 크기: 가로 451pixel, 세로 247pixel](file:///C:\Users\smpsm\AppData\Local\Temp\tmp1619.jpg)   (4) 조건 분기 명령어가 실행된다면, 미리 인출되어 파이프라인에서 처리되던 명령어들이 무효화 될 수 있다.

?    인터럽트가 들어오는 경우에도 비슷한 결과를 가져온다.

<br/>

\* 명령어 3이 명령어 12로 분기하는 조건 분기 명령어일 때,

  명령어 4부터 명령어 6까지의 명령어들은 무효화 되어,

  주기 7부터 9까지의 세 사이클은 낭비되는 것이다.

<br/>

(파이프라이닝 구조가 가지는 근본적인 것이기 때문에

완전히 해결할 수는 없지만, 보완할 수 있는 방법은 있다.)

 4-단계 파이프라인의 보완 방법.

 (1) 파이프라인 단계들을 더욱 작게 분할함으로써 처리시간의 차이를 최소화 시켜주는 슈퍼파이프라이닝 기술.

 (2) 파이프라인의 IF와 OF단계가 직접 액세스 하는 CPU 내부 캐시를 명령어 캐시와 데이터 캐시로 분리하는 방법

 (3) 조건 분기로 인한 문제점의 보완 방법

   \- 분기 예측 : 분기가 일어날 것인지 예측하고, 그에 따라 명령어를 인출하는 확률적 방법.

   \- 분기 목적지 선인출 : 조건 분기가 인식되면, 분기 명령어의 다음 명령어뿐 아니라, 조건 만족 시 분기 될

?    목적지의 명령어도 함께 인출하는 방법.

   \- 루프 버퍼 : 가장 최근 인출된 n개의 명령어들을 작은 고속 기억장치인 버퍼에 순서대로 저장해 두는 방법.

   \- 지연 분기 : 분기 명령어의 위치를 재배치함으로써 파이프라인의 성능을 개선하는 방법.

<br/>

\* 상태 레지스터 : 연산처리 결과 및 시스템 상태를 가리키는 비트들을 저장하는 레지스터

\* 플래그(flag) : 각 조건의 상태를 나타내는 비트로, 플래그를 모아둔 곳이 상태 레지스터이다.

\* 조건 플래그들

 \- 부호(S) 플래그 : 산술 연산 결과 값의 부호 비트로 세트 되며, 0은 양수 1은 음수를 나타낸다.

 \- 제로(Z) 플래그 : 연산 결과 값이 0이면 이 플래그는 1로 세트된다.

 \- 올림수(C) 플래그 : 덧셈 뺄셈에서 올림 수나 빌림 수가 발생한 경우에 세트된다.

 \- 동등(E) 플래그 : 두 수를 비교한 결과가 동일한 경우 세트된다.

 \- 오버플로우(V) 플래그 : 오버플로우가 발생한 경우 세트된다.

 \- 인터럽트(I) 플래그 : 인터럽트 가능상태이면 0, 불가능 상태이면 1로 세트된다.

 \- 슈퍼바이저(P) 플래그 : 관리자 모드 / 일반 사용자 모드를 나타내는데 사용된다.

<br/>

#### 2.3.3 슈퍼스칼라

#### 2.3.4 듀얼 코어 및 멀티 코어

<br/>

<br/>

###  2.4 명령어 세트

\* 명령어 세트 : CPU가 수행할 수 있는 명령어들이 정의되어 있는 집합.

  명령어 세트를 설계하는 것이 CPU를 설계하는 것이다.

<br/>

\* 명령어 세트를 설계하기 위해 결정해야 할 사항들

 \- 연산 종류 : CPU가 수행할 연산의 종류와 복잡도

 \- 데이터 형태 : 연산 수행 데이터의 형태로, 데이터의 길이를 말함

 \- 명령어 형식 : 명령어의 길이, 오퍼랜드 필드의 개수와 길이 등

 \- 주소지정 방식 : 오퍼랜드 주소를 지정하는 방식

<br/>

#### 2.4.1 연산의 종류

 \- 데이터 전송

 \- 산술 연산

 \- 논리 연산

 \- 입출력

 \- 프로그램 제어

   ○ CALL 명령어 : 현재의 PC내용을 스택에 저장하고 서브루틴의 시작주소로 분기하는 명령어. (서브루틴 호출)

   ○ RET 명령어 : 서브루틴에서 원래 프로그램으로 복귀시키는 명령어. (return)

<br/>

\* X번지에 위치한 서브루틴을 호출하는 CALL X 명령어의 마이크로-연산

  ![사각형입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\DRW0000684c3885.gif) 

?       t : CPU 클록의 각 주기

?       SP : Stack Pointer

?       (저장될 주소가 32bit라면 SP-4)

<br/>

\* RET 명령어의 마이크로-연산

  ![사각형입니다.](C:\Users\smpsm\Desktop\상민\School\2학년 1학기 과목\Computer architecture\공부\imgs\DRW0000684c3885.gif)

?       t : CPU 클록의 각 주기

?       SP : Stack Pointer

?       (저장될 주소가 32bit라면 SP-4)

<br/>

#### 2.4.2 명령어 형식

 \- 연산 코드 : 수행될 연산을 지정해준다.

 \- 오퍼랜드 : 연산을 수행하는데 필요한 데이터 혹은 데이터의 주소

 \- 다음 명령어 주소 : 현재의 명령어 실행 완료 후 다음 명령어를 인출할 위치를 나타낸다.

?       분기나 호출 명령어같이 실행 순서를 변경하는 경우에만 필요하다.

<br/>

  ![그림입니다.  원본 그림의 이름: 그림_2-11._16-비트_명령어_형식의_예.jpg  원본 그림의 크기: 가로 409pixel, 세로 122pixel](file:///C:\Users\smpsm\AppData\Local\Temp\tmp1649.jpg)  * 명령어 형식 : 명령어를 구성하는 필드의 종류와 개수, 배치 방식 및 필드 당 비트 수를 정의한 형식.

\* 명령어의 길이 = 단어(word)의 길이

<br/>

\* 16비트 명령어 형식의 예

 \- 연산코드 4비트, 오퍼랜드1 필드에 4비트, 오퍼랜드2 필드에 8비트 할당이 된다.

 \- 연산코드의 길이가 4비트이므로, 24=16개의 연산을 수행할 수 있다.

<br/>

\* 오퍼랜드 필드가 가능한 종류

 \- 데이터 : 표현 가능한 수의 크기가 결정된다.

 \- 기억장치 주소 : CPU가 오퍼랜드 인출을 위해 직접 주소를 지정할 수 있는 기억장치 영역의 범위가 결정된다.

 \- 레지스터 번호 : 데이터 저장에 사용될 수 있는 내부 레지스터들의 수가 결정된다.

<br/>

#### Quiz!

  16비트 명령어 형식에서, 연산코드 필드가 5bit, 오퍼랜드1은 레지스터 수를 저장하는 필드로 2bit,

  오퍼랜드2는 나머지 9bit로 지정하였다. 이 때 명령어(연산)의 수와, 사용 가능한 레지스터의 수, 그리고

  주소지정을 할 수 있는 기억장치의 주소 영역은

 => 명령어 수 : 25=32개 / 레지스터 수 : 22=4개 / 주소 영역 : 29=512, 따라서 0~511번지

<br/>

#### Quiz!

만약 오퍼랜드1과 2를 합하여 하나의 오퍼랜드 필드로 하고, 2의 보수 데이터를 저장한다면,

  데이터의 표현 범위는 얼마나 되는가

 => 오퍼랜드 필드는 11bit이므로 211=2048. 그런데 2의 보수 데이터를 저장하므로 첫 비트는 부호비트로

?     사용하여 데이터의 표현 범위는 -210 ~ 210-1 = -1024 ~ 1023이 된다.

<br/>

 1-주소 명령어 : 명령어가 한 개의 오퍼랜드만 포함하는 형식

 \- 오퍼랜드 필드의 모든 비트들이 주소지정에 사용될 수 있어, 지정 가능한 주소 영역이 커진다.

?    <br/>

#### Quiz!

길이가 16bit인 1-주소 명령어에서 연산코드가 5bit이고 각 기억장소에는 1byte씩 저장된다고 할 때,

  명령어 형식을 정의하고, 지정 가능한 기억장치의 최대 용량을 구하여라.

 => 연산코드 5bit, 기억장치주소(오퍼랜드) 11bit 로 나뉘는 명령어 형식.

 => 오퍼랜드의 크기는 16-5=11bit 이므로 211×1byte=2048Byte=2KB

<br/>

 2-주소 명령어 : 명령어가 두 개의 오퍼랜드를 포함하는 형식

 \- 오퍼랜드 필드가 두 개의 레지스터 번호만 포함하면 되기에 비트 수가 절약된다. 하지만 명령어 코드 내에

   레지스터 번호와 기억장치 주소가 모두 포함되어야 하므로 지정 가능한 주소 영역이 제한된다.

<br/>

#### Quiz!

길이가 16bit인 2-주소 명령어에서 연산코드가 5bit이고 레지스터의 수는 8개이다. 두 개의 오퍼랜드들이

  모두 레지스터 번호인 경우와, 하나는 기억장치 주소인 경우의 명령어 형식을 정의하여라.

 => 연산코드 5bit, 레지스터가 8개 이므로 23=8, 두 오퍼랜드는 3bit씩이며, 남은 5bit는 사용되지 않는다.

 => 연산코드 5bit, 레지스터 번호 오퍼랜드는 3bit, 남은 8bit는 기억장치 주소로 할당되는 명령어 형식.

<br/>

 3-주소 명령어 : 명령어가 세 개의 오퍼랜드를 포함하는 형식

 \- 오퍼랜드 필드 세 개에 4bit씩 할당 되어, 각각 최대 16개의 레지스터를 사용할 수 있다.

<br/>

 X = (A + B) × (C - D) 연산을 각 명령어 형식을 사용해 작성하기.

 \- ADD : +

 \- SUB : -

 \- MUL : ×

 \- DIV : ÷

 \- MOV : 데이터 이동

 \- LOAD : 기억장치에서 데이터를 읽어 AC(누산기)에 적재

 \- STOR  : AC의 내용을 기억장치에 저장

<br/>

 1) 1-주소 명령어를 사용한 프로그램

 LOAD A ; AC ← M[A]

 ADD B ; AC ← AC + M[B]

 STOR T ; M[T] ← AC

 LOAD C ; AC ← M[C]

 SUB D ; AC ← AC - M[D]

 MUL T ; AC ← AC × M[T]

 STOR X ; M[X] ← AC

 \- 프로그램 7개 명령어로 이루어짐.

<br/>

 2) 2-주소 명령어를 사용한 프로그램

 MOV R1, A ; R1 ← M[A]

 ADD R1, B ; R1 ← R1 + M[B]

 MOV R2, C ; R2 ← M[C]

 SUB R2, D ; R2 ← R2 - M[D]

 MUL R1, R2 ; R1 ← R1 × R2

 MOV X, R1 ; M[X] ← R1

 \- 프로그램 6개 명령어로 줄어듦.

<br/>

 3) 3-주소 명령어를 사용한 프로그램

 ADD R1, A, B  ; R1 ← M[A] + M[B]

 SUB R2, C, D  ; R2 ← M[C] - M[D]

 MUL X, R1, R2 ; M[X] ← R1 × R2

 \- 프로그램 3개 명령어로 가장 짧아짐. 하지만 명령어의 비트 수 증가, 실제로 프로그램을 저장하기 위한

   기억장치 용량은 별로 줄어들지 않고, 명령어 해독 과정이 더 복잡해진다는 단점.

<br/>

#### 2.4.3 주소지정 방식

\* 주소지정 방식 : 주소 비트들을 이용하여 오퍼랜드의 유효주소를 결정하는 방법

\* 다양한 지정방식을 사용하는 이유

 => 제한된 수의 명령어 비트들을 이용해 사용자로 하여금 여러 방법으로 오퍼랜드를 지정하고

?     더 큰 기억장치를 사용하게 하기 위함.

  \- EA : 유효주소. 즉, 데이터가 저장된 기억장치의 실제 주소

  \- A : 명령어 내의 주소필드 내용 (오퍼랜드가 기억장치 주소인 경우)

  \- R : 명령어 내의 레지스터 번호 (오퍼랜드가 레지스터 번호인 경우)

  \- (A) : 기억장치 A번지의 내용

  \- (R) : 레지스터 R의 내용

<br/>

\* 명령어의 길이가 n비트, 연산 코드의 비트가 p비트, word의 길이가 m비트일  때 주소 지정 방식

<br/>

 1)  직접 주소지정 방식

  \- 명령어 내 오퍼랜드 필드의 내용이 데이터의 유효주소로 사용되는 가장 간단한 방식. 즉, EA = A 이다.

?    메모리를 한 번만 액세스해도 된다. 대신, 직접 액세스 가능한 기억장치의 주소 공간이 오퍼랜드 필드의

?    비트 수에 의해 제한되는 것이 단점이다. 지정 가능한 기억장소의 수는 최대 2n-p 개.

<br/>

 2)  간접 주소지정 방식

  \- 오퍼랜드가 가리키는 기억장치의 내용을 유효 주소로 사용하여 연산에 필요한 데이터를 인출하는 방식. (포인터)

?    최대 기억장치 용량이 그 기억장소에 저장된 전체 비트 수에 의해 결정되므로, 범위가 확장될 수 있다.

?    이 명령어에 의해 직접 주소지정 가능한 기억장소의 수는 최대 2m 개. 유효 주소는 EA = (A) 이다. (*A처럼..)

?    실행 사이클 동안 두 번의 메모리 액세스가 필요해 느리다는 단점이 있다.

<br/>

 3)  묵시적 주소지정 방식

  \- 오퍼랜드로 데이터의 위치를 따로 지정하지 않아도 이미 묵시적으로 정해져 있다. 오퍼랜드가 없거나 한 개

?    밖에 없어 명령어 길이가 짧다는 장점이 있지만, 사용 가능한 명령어의 종류가 제한된다는 단점이 있다.

<br/>

 4)  즉시 주소지정 방식

  \- 연산에서 사용할 데이터를 명령어 코드 내에 포함하는 방식. 데이터를 인출하기 위해 기억장치를 액세스 할

?    필요가 없어 실행 사이클이 짧아지지만, 이 역시 오퍼랜드 필드의 비트 수에 의해 제한되는 것이 단점이다.

<br/>

 5)  레지스터 주소지정 방식

  \- 명령어의 오퍼랜드가 가리키는 레지스터에 저장되어 있는 데이터를 연산에 사용하는 방식. EA = R 이 된다.

?    데이터 인출을 위해 기억장치를 액세스 할 필요가 없다. 기억장치의 액세스 시간보다 레지스터의 액세스

?    시간이 훨씬 더 짧기 때문에, 실행 시간이 짧아진다. 하지만 데이터 저장 가능 위치가 CPU 내부 레지스터로

?    제한된다는 단점.

<br/>

 6)  레지스터 간접 주소지정 방식

  \- 지정된 레지스터의 내용을 유효 주소로 사용하여, 그 주소가 가리키는 기억장치로부터 읽어온 데이터를 연산에

?    사용하는 방식. EA = (R)이다. 지정할 수 있는 기억장치 영역은 레지스터의 길이에 달려있어, 확장 된다는 장점.

?    데이터 인출을 위해 한 번의 기억장치 액세스가 필요하다.

<br/>

 7)  변위 주소지정 방식

  \- 지정된 레지스터의 내용과 명령어 내 오퍼랜드(변위)를 더하여 유효 주소를 결정하는 주소지정 방식.

?    EA = A + (R) 이다. 레지스터 번호를 나타내는 R과 변위를 나타내는 주소 A 두 개의 오퍼랜드를 가진다.

?    사용되는 레지스터에 따라 여러 종류의 변위 주소 지정 방식이 사용된다.

<br/>

   => 상대 주소지정 방식

?     프로그램 카운터(PC)의 내용과 명령어 내 오퍼랜드(변위)를 더하여 유효 주소를 결정하는 주소지정 방식.

?     변위는 현재 PC의 내용을 기준으로, 상대적인 값이 된다. 범위가 오퍼랜드 필드의 비트 수에 의해 제한되지만,

?     기억장치 주소가 명령어에 포함되어야 하는 일반적인 분기 명령어보다 적은 수의 비트만 있으면 된다는 장점.

<br/>

   => 인덱스 주소지정 방식

?     인덱스 레지스터의 내용과 명령어 내 오퍼랜드(변위)를 더하여 유효 주소를 결정하는 주소지정 방식.

?     EA = A + (IX)가 된다. 주소 A는 데이터 배열의 시작 주소를 가리킨다. IX는 인덱스 레지스터로, 인덱스 값을

?     저장하는 특수 레지스터이며, 그 내용은 A로부터 각 데이터까지의 거리를 나타낸다.

?    \- 자동 인덱싱 : 유효 주소가 결정될 때마다 자동적으로 IX의 내용을 증감시키는 방식.

  EA = A + (IX)

  IX ← IX + 1

<br/>

   => 베이스-레지스터 주소지정 방식

?     베이스 레지스터의 내용과 명령어 내 오퍼랜드(변위)를 더하여 유효 주소를 결정하는 주소지정 방식.

?     EA = A + (BR)이 된다. BR에는 기준이 되는 명령어의 주소가 저장된다. 프로그램의 시작 위치를

?     지정 하는데 사용된다.