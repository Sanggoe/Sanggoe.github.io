## 01. 컴퓨터시스템 개요

<br/>

###  1.1 컴퓨터의 기본 구조

* 컴퓨터 : 필요한 데이터를 읽고(read), 처리하고(processing), 결과를 저장한다(store).

* CPU(Central Processing Unit, 프로세서) : 프로그램 실행, 데이터 처리를 맡는 중추적 역할.

* 기억장치(Memory, 저장장치)
  * 주기억장치(main memory) : 속도가 빠르지만, 전원이 공급 될 때만 사용 가능한 일시적 기억장치.

  - 보조저장장치 : 속도가 느리지만, 저장 용량이 큰 영구적 기억장치. 주변장치로 분류하기도 함. harddisk, USB 등.

* 입출력장치(I/O divice) : 사용자와 컴퓨터간의 상호작용을 위한 장치. 마우스, 키보드, 모니터 등.

<br/>

<br/>

### 1.2 정보의 표현과 저장

* 프로그램 코드, 데이터 : 2진수 bit형태로 표현 된다.

  => high level language에서 작성 후 컴파일러에 의해 low level language인 기계어로 변환.

* 어셈블리 언어 : 고급언어와 기계어 사이의 CPU 고유의 중간 언어.
  * 어셈블러 : 어셈블리 언어를 기계어로 변환해주는 프로그램. (컴파일러 역할)

<br/>

★ 명령어 형식 : 명령어의 필드와 오퍼랜드 필드가 사용하게 될 비트 수를 지정하는 형식을 말한다.

![그림입니다.](./imgs/tmpFF75.jpg)

- 연산코드 필드 : STORE / ADD / LOAD 등의 명령어가 담기는 필드.

- 오퍼랜드 필드(데이터 라고 쓰인부분) : 데이터가 저장되어 있는 기억장치 주소가 담기는 필드.
- 단어(word) : CPU에 의해 한 번에 처리될 수 있는 비트들의 그룹. (이 책에선 8bit 컴퓨터라 1byte로 가정)

<br/>

#### Quiz!

> 16비트 명령어에서 6비트는 연산코드, 나머지 비트들은 오퍼랜드로 사용된다.

  1) CPU가 수행할 수 있는 연산의 종류의 최대 개수는?

  => 연산코드가 6비트이므로 26 = 64가지.

  2) 오퍼랜드(데이터)가 기억장치 주소를 가리키고, 각 기억장소에는 워드(=1byte)단위로 저장된다면,

?    이 명령어에 의해 직접 주소지정 될 수 있는 기억장치의 용량은 몇 바이트인가?

  => 오퍼랜드가 10비트이므로 210×1byte = 1KB

?    

###  1.3 시스템의 구성

#### 1.3.1 CPU와 기억장치의 접속

★ 시스템 버스(system bus) : CPU와 시스템 내 다른 요소들 사이에 정보를 교환하는 통로.

- 주소 버스(address bus) : CPU가 외부로 발생하는 주소 정보를 전송하는 신호 선들의 집합. CPU가 발생하는 주소 비트들의 수를 주소버스의 폭(width)이라고 하는데, 폭이 8bit 라면 최대 28 = 256개(32Byte), 폭이 16bit 라면 최대 216 = 65,536개(64KB)의 주소를 지정해 줄 수 있다. CPU에서 발생되어 보내지기 때문에, 단방향성.

- 데이터 버스(data bus) : CPU와 기억장치 또는 I/O 장치 사이에 데이터를 전송하기 위한 신호 선들의 집합. 데이터 버스가 32비트인 시스템에서는 CPU가 기억장치로부터 한 번에 32비트씩 읽어 올 수 있다. 데이터 버스는 읽기 쓰기동작 모두 지원해야 하므로 양방향성.

- 제어 버스(control bus) : CPU가 시스템 요소들의 동작을 제어하기 위한 신호 선들의 집합.

![그림입니다.  원본 그림의 이름: 2.PNG  원본 그림의 크기: 가로 381pixel, 세로 356pixel](./imgs/tmpFF86.jpg)

<br/>

<br/>

#### Quiz!

> 주소 버스의 폭(bit수)에 따른 기억장치 용량 예

1) CPU와 기억장치간 접속된 주소 버스가 12bit / 16bit 일 때, 주소가 1byte 단위로 지정 된다면, 이 컴퓨터의 최대 기억장치 용량은 몇 바이트인가?

 => 212×1byte = 210×22×1 = 1KB×4×1 = 4KB

 => 216×1byte = 210×26×1 = 1KB×64×1 = 64KB 

<br/>

* 기억장치 쓰기 시간 : CPU가 기억장치로 주소, 데이터를 보낸 순간부터 저장이 완료 될 때까지의 시간.

* 기억장치 읽기 시간 : CPU가 기억장치로 주소와 데이터를 보낸 순간부터 읽기 동작이 완료 될 때까지의 시간.

<br/>

2) 아래 두 그림이 차이가 나는 이유는?

  ![묶음 개체입니다.](./imgs/DRW0000684c3858.gif)  

 => (a)는 기억장치 쓰기 동작의 시간 흐름도로, 데이터를 저장할 주소와 저장할 데이터를 각각 주소버스와 데이터 버스를 통해 보내면서 동시에 쓰기 신호를 활성화 시킨다. (b)는 기억장치 읽기 동작의 시간 흐름도로, (a)와 다르게 데이터를 읽어올 주소를 주소버스를 통하여 보내면서 읽기 신호를 활성화 시킨다. 그리고 일정 지연시간이 지난 후 기억장치로부터 읽힌 데이터가 데이터 버스에 실리게 된다. 주소를 해독하는데 걸리는 시간과 기억장치로부터 데이터를 인출하는데 걸리는 시간을 합한 시간인 지연시간 때문에 (a)와 (b)의 데이터 버스의 시간 흐름도가 차이가 난다.

<br/>

#### 1.3.2 CPU와 I/O 장치의 접속

* CPU와 I/O 장치간의 연결에 대해

 - CPU는 메인메모리에게 직접 명령을 내리고, 데이터를 직접 받아간다. 하지만, 각 장치들에게는 CPU가 직접 제어

  하지 못하고, 장치별로 별도의 인터페이스 회로나 제어기에게 대신 명령을 내려서 제어한다.

 - 제어기에는 각 장치의 상태에 대한 정보와, 내용에 대한 정보만 가지고 있고, CPU가 입력 장치를 주기적으로

  체크해서 정보를 읽어간다.

 - CPU 명령어 한 개의 처리속도 : 3.2GHz 일 경우 => 103×103×103×3.2 = 32억분의 1초.

<br/>

![그림입니다.](./imgs/tmpFFD5.jpg)

* ex) CPU가 키보드로부터 데이터를 읽어 들이는 과정
  * 키보드의 key가 눌림 ->
  * 그에 해당하는 8비트(ASCII코드 7비트 + 패리티 비트) 데이터가 키보드 제어기로 전송 ->
  * 데이터 레지스터 (data register) 에 저장(어떤 것이 입력되었는지), 동시에 상태 레지스터 (status register)에  지정된 비트가 저장(눌린 상태인지 아닌지 0 or 1로 저장) ->
  * CPU가 주기적으로 키보드 제어기의 상태 레지스터를 체크하여 비트가 1이면, 데이터 레지스터의 내용을 CPU로 읽어 들임으로써 데이터 입력과정이 완료.

<br/>

  ![그림입니다.](./imgs/tmpFFE6.jpg)  

* ex) CPU가 데이터를 프린트하는 과정
  * CPU가 프린터 제어기 내의 상태 레지스터를 읽어서 1이면, CPU는 프린트 할 데이터를 프린터 제어기의 데이터 레지스터로 쓰게 됨 ->
  * 이 데이터 레지스터는 CPU와 I/O 장치 사이에 임시 저장 장소 역할을 하기 때문에, 데이터버퍼(data buffer) 라고도 불림

<br/>

- 데이터 : 관심 있는 주요 정보  /   메타 데이터 : 데이터에 대한 정보

- 트랙 버퍼 / 디스크 버퍼 : 디스크의 한 트랙 내용을 임시 저장하는 반도체 기억장치.

?      더 큰 용량인 경우에 디스크 또는 캐시 버퍼라고 불림.

<br/>

#### 1.3.3 전체 시스템의 구성

  ![그림입니다.](./imgs/tmpFAD2.jpg)  

* 컴퓨터 시스템의 전체 구성도

 - 프로그램 실행 : CPU가 주기억장치로부터 프로그램 코드를 읽어 실행

 - 데이터 저장 : 프로그램 실행 결과로 얻은 데이터를 주기억장치에 저장

- 데이터 이동 : 디스크나 CD-ROM에 저장된 프로그램과 데이터 블록을 주기억장치로 이동한다.

- 데이터 입력 및 출력 : 사용자가 키보드를 통해 보내는 명령이나 데이터를 읽어 들인다. 또한 CPU가 처리한 결과 값이나 기억장치의 내용을 출력한다.

<br/>

<br/>

### 1.4 컴퓨터 구조의 발전 과정

#### 1.4.1 초기 컴퓨터들의 구조

#### 1.4.2 주요 컴퓨터 부품들의 발전 경위

 - 폰노이만 아키텍쳐(von Neumann Architecture)

#### 1.4.3 컴퓨터시스템의 분류와 발전 동향

 - 임베디드 컴퓨터(embedded computer: 내장 컴퓨터라고도 함)

#### 1.4.4  등등.. 은 뭐 그냥 이런저런 이야기들.