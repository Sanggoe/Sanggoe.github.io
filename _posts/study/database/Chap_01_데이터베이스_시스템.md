# Chap 01. 데이터베이스 시스템

<br/>

<br/>

## 01 데이터베이스와 데이터베이스 시스템

* 데이터 / 정보 / 지식

<br/>

### 데이터베이스란?

* 데이터의 모음. a set of data.
* 사전적 정의: 조직에서 필요한 정보를 얻기 위해 논리적으로 연관된 데이터를 모아 구조적으로 통합해 놓은 것.
  * 영수증 분석 해보면 DB에 대해 알 수 있다.

<br/>

### 데이터베이스의 개념 (정의)★

**1) 통합된 데이터 (integrated data)**

>  **데이터를 통합**하는 개념.
> 각자 사용하던 **데이터의 중복을 최소화**하여 중복으로 인한 **데이터 불일치 현상**을 제거.

* 만약 통합이 안된다면 어떤 문제가 발생할까? 같은 조직에서 각자 자기 데이터를 가지고 있을 경우
  * 메모리가 낭비가 된다.
  * **데이터가 불일치**가 일어날 수 있다. 학교 조직에서 각 부서별로 학생 데이터를 각자 가지고 있다고 예시 들어 이해하자.

<br/>

**2) 저장된 데이터 (stored data)**

> 문서로 보관된 데이터가 아니라 디스크, 테이프 같은 컴퓨터 **저장장치에 저장**된 데이터를 의미.

* 휘발성 날라가는 메인메모리가 아니라 secondary memory. storage에 주로 저장된다.
* 근데 issue! 하지만 **secondary storage에 read write를 하면 프로세서 cpu가 처리하는 속도를 못따라간다.**

* 위 이슈를 **폰 노이만 병목**(Von-Neumann **Bottleneck**)**현상** 이라고 한다.
  * (일반적으로 **자료 경로의 병목현상** 또는 **기억장소의 지연 현상**을 이르는데, 이는 나열된 명령을 순차적으로 수행하고, 그 명령은 일정한 기억장소의 값을 변경하는 작업으로 구성되는 폰 노이만 구조에서 기인한다. - 위키백과
* 따라서 데이터베이스에서는 **이 시간을 최소화하는 것**이 중요한 이슈라고 한다.

<br/>

* 저장 데이터
  * Read Write 할 때의 단위, Block 단위로 swap in / out 한다.
  * 어떻게 구성하면 빠르게 읽고 쓰고 할 것인가? 이것이 DB 관리자가 하는 일.
  * 이걸 주기적으로 최적화(optimize) 해줘야 함.
  * 속도가 중요하다! 느린 이유는 용량이 크기 때문에 Disk 저장장치를 쓰기 때문이다.

<br/>

**3) 운영 데이터 (operational data == organization data)**

> 저장만 하는 목적보단, **조직의 목적**을 위해 사용되는 데이터를 의미한다.
> 즉 업무를 위한 검색을 할 목적으로 저장된 데이터.

<br/>

**4)** **공용 데이터** **(shared data)**

> 한 사람 또는 한 업무를 위해 사용되는 데이터가 아니라 **공동으로 사용되는 데이터**를 의미

* 개인적으로 쓸 용도라면 DB 쓸 필요도 없다. 왜? 일단 느려. 걔가 하는 일이 많기 때문에.
* 지혼자 계속 옵티마이징 하고 디스크에서 왓다갓다 하니까... 그리고 무거워. Heavy 해. 비싸.
* 여러명이 사용하는게 기본이다. 어떻게 하면 여러명이 문제를 일으키지 않고 동시에 사용하느냐?
* Like a 운영체제. 크리티컬 섹션 그런거 나오는.. 암튼. Sharing이 기본이다!

<br/>![tmp94E9](./imgs/tmp94E9.jpg)  

<br/>

<br/>

### 데이터베이스의 특징 ★

**1) 실시간 접근성 (real time accessibility)**

> 데이터베이스는 **실시간으로 서비스** 된다.

* 사용자가 데이터를 요청하면 몇 시간이나 몇 일 뒤에 결과를 전송하는 것이 아니라, 수 초 내에 결과를 서비스한다.

<br/>

**2) 계속적인 변화 (continuous change) == 동적 dynamic**

> 데이터베이스 저장된 내용은 어느 한 순간의 상태를 나타내지만, **데이터 값은** 기간에 따라 **항상 바뀐다**.

* 데이터베이스는 **삽입(insert), 삭제(delete), 수정(update)** 등의 작업을 통하여 바뀐 데이터 값을 저장한다.
* 정말 기본 기능! 삽입, 삭제, 수정이 안되면 그건 DB가 아니다.

<br/>

**3) 동시 공유 (concurrent sharing)**

> 데이터베이스는 서로 다른 업무 또는 여러 사용자에게 동시에 공유된다.

* 동시(concurrent)는 병행이라고도 하며, 데이터베이스에 접근하는 프로그램이 여러 개 있다는 의미다.
  * 운영체제에서 프로세스들이 리소스를 동시에 사용하는 것처럼.
  * 통합된 데이터베이스가 있으면, 여러 부서에서 여러 명이 동시에 사용해야 한다.
  * 하지만 엄밀히 따지면.. 동시에 사용할 순 없고, 누가 사용했으면 Lock을 걸고, 풀고, 걸고, 풀고 하는걸 아주 잠깐의 시간동안 이루어지기 때문에 사용자가 못 느끼는것 뿐이지, 실제론 그렇다.
  * DB를 팔 때, 기본적으로 몇 명의 User가 쓸 것이냐? 에 따라서 달라지게.
  * 동시 공유의 User 수가 많아질수록 기하급수적으로 비싸진다...
* 여러명이 동시에 사용할 수 있도록 잘 제어해주는 것을 **concurrency control** 이다.
* 이것 역시 DB 설계에서의 issue. 누가 해주냐? DBMS가 알아서 해준다. 오라클에서. MS에서...

<br/>

**4) 내용에 따른 참조 (reference by content) == 값에 의한 참조 (call by value)**

> 데이터베이스에 저장된 데이터는 데이터의 물리적인 **위치가 아니라 데이터 값에 따라 참조**된다.

* **Call By Reference**가 아니라, **Call By Value**이다!! 뒤에서 설명 할 거야.

<br/>

<br/>

### 데이터베이스 시스템 (DataBase System) ★

  ![tmp94F9](./imgs/tmp94F9.jpg)  

* 요렇게 **데이터베이스**, **DBMS**, 또 DBMS를 사용하는 **User**s, 그리고 DB와 관련된 모든 기계까지 전부 다 합한 걸 **데이터베이스 시스템** (DBS) 이라고 말한다.
* 저자마다 학자마다 이것에 대한 정의는 다르지만... 우리는 이렇게 이해하고 있자.

<br/>

  ![tmp950A](./imgs/tmp950A.jpg)  

* DBMS는 프로그램. 소프트웨어. 설치를 하면, 돌아가는 것
* DataBase는 File 형태로 저장되어 있을 것
* 데이터 모델은 실제로 존재하는게 아니라, 추상적인 개념.

<br/>

* 일반 사용자는 그냥 사용자 Clients.
* 응용 프로그래머는 우리 같은, DB를 Java에 연동시킨다던가 그런 일 하는 개발자쯤?
* SQL 사용자는 DB에 사용하는 언어를 사용해 조작하는 사용자. 응용 프로그래머가 될 수도 있고, 관리자가 될 수도 있다.

<br/>

#### 위에 배운 내용을 토대로 정리하면..

* DB는 소프트웨어다? No!
* DBS는 소프트웨어다? No!
* **DBMS**는 소프트웨어다? Yes!

<br/>

<br/>

## 02 데이터베이스 시스템의 발전

* 마당서점과 데이터베이스 시스템 (예시)

>  [1단계] 마당서점 시작. 100권, 장부에 기록
>
>  [2단계] 컴퓨터의 도입. 1,000권, 컴퓨터 파일 시스템
>
>  [3단계] 지점 개설 및 DB 구축, 10,000권, DB 시스템
>
>  [4단계] 홈페이지 구축, 100,000권, 컴퓨터와 인터넷 사용, 웹 DB 시스템
>
>  [5단계] ... 뭐 예시 든거니까. 그렇게 발전 했을거라구. 규모가 커질수록 DB 필수라는거지

<br/>

#### 1. 파일 시스템(File System)의 경우

* Data를 파일 단위로 파일 서버에 저장
* 각 컴퓨터는 LAN으로 파일 서버에 연결. 데이터 사용을 위해 컴퓨터의 응용 프로그램에서 open/close를 요청

* 각 응용 프로그램이 독립적으로 파일을 다루기 때문에 **데이터 중복** 저장의 가능성 있음
* 동시에 파일을 다뤄 **일관성이 훼손**될 수 있어 **데이터의 불일치**(data inconsistency) 발생

   <img src="./imgs/tmp952A.jpg" alt="tmp952A" style="zoom: 67%;" />        <img src="./imgs/tmp953B.jpg" alt="tmp953B" style="zoom: 67%;" />  

<br/>

#### 2. 데이터베이스 시스템의 경우

* **DBMS**를 도입하여 **Data를 통합 관리**하는 시스템
* DMBS가 설치되어 **데이터를 가진 쪽을 서버(server), 외부에서 데이터 요청하는 쪽을 클라이언트 (client)** 라고 함
* DBMS 서버가 파일을 다루며 데이터의 **일관성(consistency) 유지, 복구(recovery), 동시 접근 제어(concurrency control)** 등의 기능을 수행
* 데이터의 중복을 줄이고 **데이터를 표준화(formating) 하며 무결성(integrity)**을 유지함

<br/>

* DB의 경우, 그 위에 DBMS가 있다는 것!
* 내용이 중복이 없도록 일관성이 있게 지속적으로 계속 관리해준다는 것..
* 위의 것들을 알아서 다 해준다는 것이 중요하다!!

<br/>

<br/>

## 03. 파일 시스템과 DBMS

* 데이터베이스는 만들어놓고 검색을 제일 많이 한다. 삽입 삭제도 매우 빈번!

<br/>

### 마당서점 데이터를 저장하는 방법에 대한 비교

#### 1.1 데이터를 프로그램 내부에 저장하는 방법

* C언어의 구조체 Book을 먼저 선언한 후, main()에서 BOOKS[]에 데이터를 저장\
* 도서 데이터는 프로그램 내 구조체 변수에 저장

> **문제점!**

* **데이터가 변경될 때마다 프로그램을 수정 후 다시 컴파일이 필요!**
* 프로그램과 데이터가 혼재해 있음!

<br/>

#### 1.2 파일 시스템을 사용하는 방법

* Book 데이터 구조 선언 후, main()에서 파일 데이터를 불러와 구조체 배열 변수에 저장
* **데이터**가 **변경**되어도 **프로그램을 수정할 필요는 없음**

> **문제점!**

* 같은 파일을 두 개 프로그램이 공유하는 것이 운영체제 도움 없이 불가능! (무결성 문제)
* **데이터 구조(type)를 바꾸면 프로그램을 수정해야 함** ★

<br/>

#### 1.3 DBMS를 사용하는 방법

* 데이터 정의와 값을 **DBMS가 관리**
* **DBMS**는 데이터 정의, 변경 등의 작업을 할 수 있는 **별도 프로그램을 내재**
* **프로그램에 데이터 정의나 값을 포함하지 않기 때문에 데이터 구조가 바뀌어도 다시 컴파일 할 필요가 없음★**

* C언어 안에 SQL이 Embedded 되어 사용된다! ESQL!

<br/>

<br/>

#### 다시 정리하면

**1) 첫 번째 프로그램**

  ![tmp954B](./imgs/tmp954B.jpg)  

<br/>

**2) 두 번째 프로그램, File System 사용**

  ![DRW000041382bc2](./imgs/DRW000041382bc2.gif)  

<br/>

**3) 세 번째 프로그램, DBMS 사용**

![tmp959B](./imgs/tmp959B.jpg)  

 <br/>

<br/>

#### 파일 시스템과 DBMS의 비교

| **구분**            | **파일 시스템**                                     | **DBMS**                                    |
| ------------------- | --------------------------------------------------- | ------------------------------------------- |
| 데이터 정의 및 저장 | 데이터 정의 : 응용 프로그램데이터저장 : 파일 시스템 | 데이터 정의 : DBMS데이터저장 : 데이터베이스 |
| 데이터 접근 방법    | 응용 프로그램이 파일에 직접 접근                    | 응용 프로그램이 DBMS에파일 접근을 요청      |
| 사용 언어           | 자바,C++, C 등                                      | 자바,C++, C 등과 SQL                        |
| CPU/주기억장치 사용 | 적음                                                | 많음                                        |

<br/>

  ![tmp95AB](./imgs/tmp95AB.jpg)  

**그림** **1-21** **파일 시스템으로 구축된 구매 및 판매 응용 프로그램**     

<br/>

<br/>

#### DBMS의 장점★

| **구분**                                         | **파일 시스템**                                              | **DBMS**                                                     |
| ------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| (1) **데이터 중복★**<br />(1) **데이터 일관성★** | 데이터를 파일 단위로저장하므로 **중복 가능** 데이터를 중복 저장으로 **일관성이 결여**됨 | DBMS를 이용하여 데이터를 공유하기 때문에 **중복 가능성 낮음** 중복 제거로 데이터의 **일관성이 유지**됨 |
| (2) **데이터 독립성★**                           | **데이터 정의**와 **프로그램의 독립성 유지 불가능<br />(프로그램이 데이터 정의에 종속적)** | **데이터 정의와 프로그램의 독립성 유지 가능<br />(프로그램이 데이터 정의에 독립적)** |
| 관리 기능                                        | 보통                                                         | 데이터 **복구**, **보안**, **동시성 제어**,데이터 관리 기능 등을 수행 |
| 프로그램 개발 생산성(사용이 편리해야)            | 나쁨                                                         | 짧은 시간에 큰 프로그램을개발할 수 있음                      |
| 기타 장점                                        | 보통                                                         | 데이터 **무결성유지**, 데이터 표준 준수 용이                 |

- 상위 두 개는 파일시스템을 사용하다가 DBMS가 출현하게 된 이유와 같다.

<br/>

#### 데이터 정의와 프로그램의 종속성 (dependency) ★

- 데이터 정의(구조)를 바꾸면, 프로그램도 바꿔야 한다! 프로그램이 데이터 정의에 종속적

<br/>

#### **데이터 정의와 프로그램의 독립성(independency)★**

* 데이터 정의(구조)를 바꿔도 프로그램을 수정하지 않아도 된다! 프로그램이 데이터 정의에 독립적

<br/>

<br/>

## 04. 데이터베이스 시스템(DBS)의 구성

​    

  ![tmp95CB](./imgs/tmp95CB.jpg)  

뒤에서 다시 설명!



### 1. 데이터베이스 언어

#### SQL

* 데이터 정의어(DDL, Data Definition Language)
* **데이터 조작어**(DML, Data Manipulation Language)
* 데이터 제어어(DCL, Data Control Language)
  * 우리가 여태 쓰던 언어들보다 High Level Language인 듯하다.
  * 매우 간결하다! 딱 내가 필요한 것만 간단하게 전달해주면 알아서 다 해준다.

<br/>

<br/>

### 2. 데이터베이스 사용자

#### 일반사용자

* 은행의 창구 혹은 관공서의 민원 접수처 등에서 데이터를 다루는 업무를 하는 사람
* 프로그래머가 개발한 프로그램을 이용하여 데이터베이스에 접근 일반인

<br/>

#### 응용프로그래머

* 일반 사용자가 사용할 수 있도록 프로그램을 만드는 사람
* 자바, C, JSP 등의 프로그래밍 언어와 SQL을 사용하여 일반 사용자를 위한 사용자 인터페이스와 데이터를 관리하는 응용 로직을 개발

<br/>

#### SQL 사용자

- SQL을 사용하여 업무를 처리하는 IT 부서의 담당자
- 응용 프로그램으로 구현되어 있지 않은 업무를 SQL을 사용하여 처리

<br/>

#### 데이터베이스 관리자(DBA, Database Administrator) ★

- 데이터베이스 운영 조직의 데이터베이스 시스템을 총괄하는 사람
- 데이터 설계, 구현, 유지보수의 전 과정을 담당
- 데이터베이스 사용자 통제, 보안, 성능 모니터링, 데이터 전체 파악 및 관리, 데이터 이동 및 복사 등 제반 업무를 함

<br/>

|                         | **SQL 언어** | **프로그래밍 능력** | **DBMS 지식** | **데이터 구성** |
| ----------------------- | ------------ | ------------------- | ------------- | --------------- |
| **일반 사용자**         | ×            | ×                   | ×             | ×               |
| **SQL 사용자**          | ◎            | ×                   | O             | O               |
| **응용 프로그래머**     | ◎            | ◎                   | O             | O               |
| **데이터베이스 관리자** | ◎            | O                   | ◎             | ◎               |

**표 1-7 데이터베이스사용자 별로 갖추어야 할 지식 수준(× : 없음, O: 보통, ◎ : 높음)**

<br/>

<br/>

### 3. DBMS

| 데이터 정의(Definition)<br />(DDL을 사용)****          | **데이터의 구조를 정의** 하고 데이터 구조에 대한 **삭제** 및 **변경 기능**을 수행 |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| **데이터 조작(Manipulation)<br />(DML을 사용)**        | 데이터를 조작하는 소프트웨어(응용 프로그램)가 요청하는 **데이터**의 **삽입**, **수정**, **삭제** 작업을 지원 |
| **데이터 추출(Retrieval)<br />(쿼리문 or DML을 사용)** | 사용자가 **조회**하는 **데이터** 혹은 응용 프로그램의 데이터를 **추출**<br />(정확히는, **조회하는 것만 Query문**이라고 함) |
| **데이터 제어(Control)<br />(DCL을 사용)**             | 데이터베이스 사용자를 생성하고 모니터링 하며 접근을 제어.<br />**백업**과 **회복**, **동시성 제어** 등의 기능을 지원함 |

**표 1-8 DBMS의 기능**

<br/>

#### 데이터 구조와 데이터의 차이를 잘 구분하자 ★

* 복습 및 추가 설명!
  * 파일 시스템의 경우 데이터 구조를 typedef 등 struct로 프로그램 안에 정의를 한다.
  * 그에 비해 데이터베이스가 데이터 정의어, 조작어, 쿼리문, 제어문 언어 인터페이스 등을 갖고 있어야 하고, 사용자에게 제공하고, 기능을 수행해야 한다. 
  * **Program Language**들도, 각자의 Paradigm에 의해 돌아간다. 절차지향, 객체지향, 뭐 그런.
  * 하나의 패러다임들이 시간이 지나면서 등장을 하게 된다. 데이터베이스도 마찬가지다!

<br/>

<br/>

### 4. 데이터 모델

* 계층 데이터 모델(**hierarchical** data model)
* 네트워크 데이터 모델(**network** data model)
* 객체 데이터 모델(**object** data model)
* **관계 데이터 모델**(**relational data model**) **→** **가장 많이 쓰인다**
* **객체-관계 데이터 모델**(**object-relational data model**) **→** **관계 데이터 모델과 객체 데이터 모델의 장점을 결합한 모델**
  * 어떤 DBMS를 사면, 그건 특정한 데이터 모델을 따른다!

<br/>

**1) 포인터 사용 : 계층 데이터 모델, 네트워크 데이터 모델**

* 현재 상용화된 **DB의 특징**을 기억하자. **Call By Value** **형식**이지, call by reference가 아니다.
  * 즉 이건 현재 잘 안 쓰인다는 의미. 중요하진 않다는 의미~
  * **포인터**를 따라가면 **느리다**는 단점이 있어 효율이 안좋음.
* 트리 형태면 계층, 그래프 형태면 네트워크 데이터 모델.

  ![tmp95EC](./imgs/tmp95EC.jpg)  

<br/>

**2) 속성 값 사용 : 관계 데이터 모델 (Relational Data Model)**

* 값에 의한 참조이다. 간단하면서도 효율성이 좋다.
  * 여기서는 포인터를 사용하지 않고, 그냥 해당하는 값을 붙이면 된다.
  * str | str | str 전체를 의미하는 게 ID다. 각 항목은 그냥 과목 코드, 과목 이름일 뿐.. 속성 값을 보면 **값**이다.
  * 값에 의한 호출이라는 사실을 기억하자!

  ![tmp95FC](./imgs/tmp95FC.jpg)  

<br/>

**3) 객체 식별자 사용 : 객체 데이터 모델 (Object Data Model)**

* oid. object id. 객체 마다 가지고 있는 고유 id로 주소와 비슷하다.
  * 초기의 주소값을 참조하는 포인터 사용 데이터 모델과 비슷하지 않나? 복잡하고...
  * 그래도 나름 객체지향이라 쓰인 곳이 꽤 있었다고 한다. 물론 “1990년대에 잠깐, 반짝..”

  ![tmp960D](./imgs/tmp960D.jpg)  

<br/>

  ![tmp961E](./imgs/tmp961E.jpg)  

<br/>

  ![tmp962E](./imgs/tmp962E.jpg)  

<br/>

   ![tmp963F](./imgs/tmp963F.jpg)  

<br/>

#### 앞에서 설명 안 한 데이터베이스 시스템의 구성을 다시 보자!

  ![tmp964F](./imgs/tmp964F.jpg)  

<br/>

* **트랜잭션**(**Transaction**) : operation 모음이라고 생각하면 된다. DB에서 어떤 작업의 단위.

<br/>

<br/>

### 5.1 3단계 데이터베이스 구조

  ![tmp9660](./imgs/tmp9660.jpg)  

<br/>

* 사용자가 데이터 베이스에 직접 접근하기가 어려우므로 그 위에 몇 단계가 더 있는 것이다. 
* **데이터는 하나**이고, **Schema**가 세 단계로 구성**된 것.**
  * Schema는 **type, class와 비슷한 의미**라고 했었다.
  * 데이터가 세 단계면 큰일난다. 그럼 중복이다;;

<br/>

* 데이터가 저장되어 있는데, 제일 아래쪽에 있는게 내부 스키마.
* 그 위에 개념 스키마가 중심이다. 모든 데이터가 모이는, 보이는 것이 바로 개념 스키마다.
* 외부 스키마는 개념 스키마 위에서 어떻게 바라보냐에 따라 여러 개가 생길 수 있다.
  * 물리적으로 데이터는 맨 아래 DB에 하나 있고, 스키마가 여러 계층으로 정의되어있는 것!!
* 사용자들은 각각의 외부 스키마 위에 붙어있다.
* 매핑(Mapping)은, 대응관계를 써준 것이 매핑이다! 저기 스키마 사이 화살표들이 매핑..

<br/>

#### 외부 스키마 (external schema = sub schema)

* 일반 사용자나 응용 프로그래머가 접근하는 계층으로, 전체 데이터베이스(개념 스키마) 중 하나의 논리적인 부분을 의미한다. (**일부분**)
* 여러 개의 외부 스키마가 있을 수 있음
* 서브 스키마(**sub schema**)라고도 하며, 관계 모델에서 **뷰**(**view**)의 개념임

<br/>

#### 개념 스키마 (conceptual schema)

* **전체 데이터베이스의 정의**를 의미 (DDL, 구조, 스키마 다 비슷한 의미로..)
* 통합 조직별로 하나만 존재하며, DBA(DataBase Administrator)가 관리함
* 하나의 데이터베이스에는 하나의 개념 스키마가 있음

<br/>

#### **내부 스키마** (**internal schema**)

* 물리적 저장 장치에 데이터베이스가 실제로 저장되는 방법의 표현
* 내부 스키마는 하나만 존재
* **인덱스**, 데이터 레코드의 배치 방법, 데이터 압축 등에 관한 사항이 포함됨
* 과거 포인터를 사용하는 모델일 때 중요했고 많이 사용했었다.

<br/>

<br/>

#### **외부/개념 매핑**

* 사용자의 외부 스키마와 개념 스키마 간의 매핑(사상)
* 외부 스키마의 데이터가 개념 스키마의 어느 부분에 해당 되는지 대응시킴

<br/>

#### **개념/내부 매핑**

* 개념 스키마의 데이터가 내부 시키마의 물리적 장치 어디에 어떤 방법으로 저장되는지 대응시킴

<br/>

**3단계 데이터베이스 구조를 구현하려면 매핑이 꼭 있어야 한다!**

<br/>

<br/>

#### 수강신청 데이터베이스 예시

  ![tmp9680](./imgs/tmp9680.jpg)

* **개념 스키마**
  * 데이터가 하나도 없다. 껍데기만 있을 뿐!
  * 객체지향으로 보면 **class**, 언어로 보면 **type**. **틀**만 있다. 이런걸 **schema** 라고 한다!
  * 데이터베이스가 아니라, **데이터베이스 구조**다!

<br/>

<br/>

  ![tmp9691](./imgs/tmp9691.jpg)  

* **수강등록 담당 DB (외부스키마1)**
  * 첫 번째 외부 스키마.
  * 학교 DB 전체가 아니라, 필요한 **일부분만** 사용자에 맞추어 보여주는 데이터베이스 구조다.
  * 부분집합 구조에 해당하는 것만 보이는 것.
  * 수강등록 담당 부서에 해당하는 사람들은, **일부분의 집합만큼만 접근할 수 있는 권한**을 주는 것이다.

<br/>

<br/>

  ![tmp96A2](./imgs/tmp96A2.jpg)  

* **시간표 담당 부서 DB (외부 스키마2)**
  * 두 번째 sub schema.
  * 마찬가지로 시간표를 담당하는 부서에서 딱 필요한 부분들로만 구성 되어있는 DB 구조만을 접근할 수 있도록 허용한다.
  * 이렇게 external schema의 개념을 이해해 가자~

<br/>

<br/>

  ![tmp96B2](./imgs/tmp96B2.jpg)  

* **수강신청 DB의 내부 스키마**
  * 외부 스키마와는 조금 다르게, 구체적으로 내용을 저장하기 위해서 몇 Byte씩 필요한지 등의 정보까지 포함하는 형식이다.
  * 이런걸 내부 스키마라고 하는 것!

<br/>

<br/>

  ![tmp96C3](./imgs/tmp96C3.jpg)  

​    

* 이렇게 **내부, 개념, 외부 스키마**들이 있다. (3단계 - Three level - architecture)
* 그래서 꼭 **스키마 내부의 항목들이 서로 다른 스키마에서 어떤 항목에 해당하는 것인지 매핑을 시켜주어야 한다**.
* 반드시 항목의 이름이 일치해야하는 것이 아니기 때문이다.
* 위의 그림 전체가 DB 속에 들어있다!

<br/>

<br/>

  ![tmp96D3](./imgs/tmp96D3.jpg)  

* 외부 스키마 위에는 사용자가 붙어있다. 하지만 DBS하고는 전혀 다른 개념이니 절대 헷갈리지 말기를~.

<br/>

<br/>

### 5.2 데이터 독립성 ★ 

* DBMS를 만듦으로써 데이터베이스 구조를 바꿔도 응용 프로그램을 바꿀 필요가 없다!
* 바로 3단계 구조를 만들어놓았기 때문에. 전에 봤던 독립성 꼭 기억하자~

<br/>

#### 논리적 데이터 독립성(logical data independence) ★

* 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원
* **논리적 구조가 변경되어도 응용 프로그램에는 영향이 없도록 하는 개념 ★**
* 개념 스키마의 테이블을 생성하거나 변경하여도 외부 스키마가 직접 다루는 테이블이 아니면 영향이 없음

<br/>

#### 물리적 데이터 독립성(physical data independence) ★

* **저장 장치 구조 변경과 같이 내부 스키마가 변경되어도 개념 스키마에 영향을 미치지 않도록 지원**
* **성능 개선을 위해 물리적 저장 장치를 재구성할 경우 개념 스키마나 응용 프로그램 같은 외부 스키마에 영향이 없음 ★**
* 물리적 독립성은 논리적 독립성보다 구현하기 쉬움

<br/>

#### 똑같은 말이지만, 다시 다른 말로 정리하자면...

* **내부 스키마**를 바꾼다고 **개념 스키마, 응용프로그램을 바꿀 필요가 없다!** 물리적 독립성.
* **개념 스키마**를 바꾼다고 **외부 스키마, 응용 프로그램을 바꿀 필요가 없다!** 논리적 독립성
  * **주체**가 뭔지 잘 기억하자. **누가 누구에게** 독립적인지. 
  * **아래 단계의 데이터 구조를 바꿔도 위의 단계를 바꿀 필요가 없다**.
  * **아랫단계 데이터 구조**를 바꿔도 **위에 단계 응용 프로그램을 바꿀 필요가 없다.**

<br/>

* **구조와 관련된 것을 정의할 때는** **Data Definition Language**. 따라서 각 스키마들과 매핑을 정의하고 변경할 때는 DDL을 사용한다.